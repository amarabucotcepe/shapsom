import streamlit as st
import pandas as pd
import warnings
warnings.filterwarnings("ignore")
from PIL import ImageFile, Image
ImageFile.LOAD_TRUNCATED_IMAGES = True
import globals
from som import rodar_algoritmo
import altair as alt
from my_utils import create_map, HEX_SHAPE, verificarColunaDesc, convert_numeric
import numpy as np
import statistics

from pagess.Relat√≥rio_SOM import pagina_som
from pagess.An√°lise_Estat√≠stica_Explorat√≥ria import pagina_analise_estatistica_exploratoria
from pagess.An√°lise_Por_Grupos import pagina_analise_por_grupos
from pagess.Anomalias import pagina_anomalias
from pagess.Relat√≥rio_das_Regi√µes import relatorio_regioes
from pagess.Relat√≥rio_dos_Munic√≠pios import relatorio_municipios

st.set_page_config(page_title="ShapSom", page_icon="üó∫Ô∏è", layout="wide")
imagem = Image.open('pixelcut-export.png')
st.image(imagem, width=256)
    
def pagina_inicial():
    """
    Function to display the initial page of the application.

    This function displays a title, options for file upload and selection, and parameters for configuring the Self-Organizing Map (SOM).
    It also provides a visualization of the SOM based on the selected data.

    Returns:
        None
    """

    st.title("**Sistema de Apoio a Auditorias do Tribunal de Contas do Estado üìä**")
    st.markdown("### üÜï Envio dos Dados")
    tipo = st.radio('**Escolha um tipo de arquivo. Os tipos de arquivo suportados para upload s√£o CSV e Excel.**',['csv','xlsx'], 
                    help="**csv** (Comma-Separated Values): Este √© um formato de arquivo simples que usa uma v√≠rgula para separar os valores. \n\n **xlsx (Excel)**: Este √© um formato de planilha criado pela Microsoft. Os arquivos Excel podem conter dados em v√°rias planilhas, al√©m de permitir a inclus√£o de gr√°ficos, f√≥rmulas e outras funcionalidades avan√ßadas. ")

    st.markdown('Atente-se a como sua planilha est√° organizada! Tente deix√°-la no formato do modelo padr√£o.')
    
    with st.expander("**Gostaria de baixar o modelo padr√£o de planilha?**", expanded=False):
        download_file = 'modelo.csv' if tipo == 'csv' else 'modelo.xslx'
        st.download_button('Modelo', 'modelo', file_name=download_file, help='Modelo de planilha a ser enviada')

    file = st.file_uploader("**Fa√ßa upload da sua planilha**", type=['csv', 'xlsx'], help='Caso sua planilha j√° esteja no mesmo formato do modelo (ou seja, com as colunas semelhantes), fa√ßa o upload dela. Caso contr√°rio, fa√ßa o download da planilha modelo e preencha com seus dados.')
    
    if file:
        tipo = file.type
        df = pd.read_csv(file, sep=',') if tipo == 'text/csv' else pd.read_excel(file)
        globals.original_database = df.copy()

        

        if(verificarColunaDesc(globals.original_database)):
            globals.current_database = globals.original_database.drop(globals.original_database.index[0]).applymap(convert_numeric)
            globals.current_database.index = globals.current_database.index-1
        else:
            globals.current_database = globals.original_database

        # st.write(df)
    
        globals.current_database = globals.current_database.dropna()
        globals.current_database_name =  file.name.split(".")[0]

        numeric_cols = list(globals.current_database.select_dtypes(include=['float64', 'int64']).columns)
        textual_cols = list(globals.current_database.select_dtypes(include=['object']).columns)
        st.divider()

        st.markdown("### ‚èèÔ∏è Defini√ß√£o dos dados de entrada e sa√≠da")

        with st.container(border=True):

            st.markdown("Caso deseje modificar a escolha de colunas padr√µes, clique na op√ß√£o abaixo:")
            with st.expander("**Escolher colunas**", expanded=False):
                st.write(df.head())
                col1, col2, col3 = st.columns(3)
                with col1:
                    globals.current_label_columns = st.multiselect("Nome", textual_cols, default=[textual_cols[0]], max_selections=1, help='Selecione a coluna que ser√° usada como o identificador principal do conjunto de dados. Esta coluna geralmente cont√©m valores √∫nicos, como nomes de munic√≠pios. Por padr√£o, √© a primeira coluna da sua planilha.')
                with col2:
                    globals.current_input_columns = st.multiselect("Entradas", numeric_cols, default=numeric_cols[:-1], help='As colunas marcadas como "Entrada" s√£o aquelas que cont√™m as vari√°veis independentes. Estes s√£o os dados que ser√£o usados para analisar o valor de sa√≠da.')
                with col3:
                    globals.current_output_columns = st.multiselect("Sa√≠da", numeric_cols, default=[numeric_cols[-1]], max_selections=1, help='A coluna marcada como "Sa√≠da" cont√©m a vari√°vel dependente ou o valor que se deseja prever ou analisar. Esta coluna representa o resultado que √© influenciado pelos dados das colunas de entrada. Por padr√£o, deve ser a √∫ltima coluna da sua planilha.')

        st.markdown("Caso n√£o queira modificar as colunas selecionadas por padr√£o, clique no bot√£o 'Enviar' e o seu Mapa SOM ser√° gerado automaticamente.")
        choose_columns = st.button("**‚úîÔ∏è Enviar**", type="secondary")

        st.markdown("### üëÄ Visualiza√ß√£o do Mapa Auto-Organiz√°vel")
        with st.container(border=True):
            if choose_columns:
                globals.table_list = []
                globals.graphic_list = []
                globals.img_list = []
                globals.som_chart = None
                globals.file_uploaded_start_flag = True

                crunched_cols = globals.current_label_columns + numeric_cols
                crunched_df = globals.current_database[crunched_cols]
                municipio_dfs = crunched_df.groupby(globals.current_label_columns[0])
                list_of_dfs = [group_df for _, group_df in municipio_dfs]
                new_df_avg = []
                new_df_std = []

                for l in list_of_dfs:
                    flatlist = lambda a : np.array(a).flatten().tolist()
                    calc_std = lambda a : statistics.stdev(a) if len(a) > 1 else 0
                    mun_txt = [l[globals.current_label_columns[0]].values[0]]
                    mun_avg = [float(np.average(flatlist(l[c].values))) for c in numeric_cols]
                    mun_std = [float(calc_std(flatlist(l[c].values))) for c in numeric_cols]
                    new_df_avg.append(mun_txt + mun_avg)
                    new_df_std.append(mun_txt + mun_std)

                ################################################################################################
                globals.crunched_df = pd.DataFrame(new_df_avg, columns=crunched_cols) # M√âDIA DAS UBS          #
                globals.crunched_std = pd.DataFrame(new_df_std, columns=crunched_cols) # DESVIO PADR√ÉO DAS UBS #
                ################################################################################################

            selected_df = df.drop(columns=globals.current_hidden_columns)

            textoSOM = '''Um Mapa SOM, ou Mapa Auto-Organiz√°vel, √© uma t√©cnica de aprendizado n√£o supervisionado usada para visualizar e organizar dados complexos 
            em uma representa√ß√£o bidimensional.        
                    '''
            st.markdown(textoSOM)

            st.markdown('''
            Atente-se as diferentes cores dentro do mapa. As cores identificam seus respectivos grupos, e cores diferentes indicam grupos diferentes. As notas
            de cada c√©lula, s√£o baseadas na vari√°vel de sa√≠da de cada munic√≠pio, vari√°vel essa definida anteriormente na Escolha de Colunas. Os tamanhos das c√©lulas variam de acordo
            com o valor dessas notas, podendo aumentar ou diminuir.
                        ''')

            st.divider()

            if globals.file_uploaded_start_flag or globals.som_chart is None:
                globals.som_chart = alt.Chart(pd.DataFrame([], columns=["x","y","Nota"])).mark_point(filled=True, shape=HEX_SHAPE).encode(
                    x=alt.X('x', scale=alt.Scale(domain=(0,30))),
                    y=alt.Y('y', scale=alt.Scale(domain=(0,30))),
                    size=alt.Size('Nota', scale=alt.Scale(domain=(0,1))),
                    color=alt.Color("Cor:N", scale=None)
                ).interactive().configure_view(fill='black').properties(width=400, height=400, title="Mapa SOM (Aguardando dados...)")
                globals.som = st.altair_chart(globals.som_chart, use_container_width=True)
            else:
                globals.som = st.altair_chart(globals.som_chart, use_container_width=True)

        st.markdown("### üîß Configura√ß√£o")
        with st.container(border=True):
            st.markdown('Caso deseje modificar os par√¢metros da cria√ß√£o do mapa SOM acima, clique para modificar os par√¢metros.')
            with st.expander("**Modificar Par√¢metros do SOM**", expanded=False):
                st.markdown('Essa √© uma op√ß√£o avan√ßada que acabar√° modificando a estrutura√ß√£o do mapa que foi gerado acima. Leia as instru√ß√µes sobre cada par√¢metro e ajuste conforme sua vontade.')
                globals.sigma = st.slider("Sigma", min_value=1, max_value=10, value=9, help="A largura da vizinhan√ßa inicial no mapa SOM. Controla a extens√£o das altera√ß√µes que ocorrem durante o treinamento. Um valor alto significa que mais neur√¥nios ser√£o influenciados durante o treinamento inicial, enquanto um valor baixo resultar√° em um ajuste mais fino.")
                globals.size = st.slider("Tamanho do mapa", min_value=5, max_value=50, value=30, help="O tamanho do mapa SOM, especificado pelo n√∫mero total de neur√¥nios (unidades). Mapas maiores podem representar caracter√≠sticas complexas com maior precis√£o, mas tamb√©m requerem mais tempo de treinamento.")
                globals.lr = st.slider("Taxa de aprendizado", min_value=-5.0, max_value=-1.0, value=-3.0, step=0.25, help="Taxa de aprendizado inicial. Controla a velocidade de adapta√ß√£o do mapa durante o treinamento. Valores muito altos podem levar a uma converg√™ncia inst√°vel, enquanto valores muito baixos podem resultar em um treinamento lento.")
                globals.epochs = st.slider("√âpocas", min_value=100, max_value=30000, step=100, value=10000, help="N√∫mero de √©pocas (itera√ß√µes) de treinamento. O n√∫mero de vezes que o mapa ser√° treinado em rela√ß√£o aos dados de entrada. Mais √©pocas geralmente resultam em um mapa mais bem ajustado, mas tamb√©m aumentam o tempo de treinamento.")
                globals.cluster_distance = st.slider("Dist√¢ncia dos agrupamentos", min_value=0.5, max_value=3.0, step=0.25, value=1.5, help="A dist√¢ncia m√≠nima entre agrupamentos de neur√¥nios para considerar a forma√ß√£o de grupos distintos. Valores mais altos podem resultar em agrupamentos mais distintos, enquanto valores mais baixos podem mesclar grupos semelhantes.")
                globals.topology = st.radio("Topologia", options=["Retangular", "Hexagonal"], index=1, help="Topologia do mapa SOM para forma√ß√£o de vizinhan√ßas.")
                globals.output_influences = st.radio("Coluna de sa√≠da influencia nos resultados (experimental)", options=["Sim", "N√£o"], index=0, help="Se a coluna de sa√≠da dos dados de entrada influencia nos resultados finais. Selecione 'Sim' para permitir que a coluna de sa√≠da tenha impacto na organiza√ß√£o do mapa, ou 'N√£o' para desconsiderar a coluna de sa√≠da durante o treinamento.")
                update_map = st.button("**Alterar par√¢metros**")
                

            has_enough_data = globals.current_label_columns and globals.current_output_columns and len(globals.current_input_columns) >= 2
            if (update_map or globals.file_uploaded_start_flag) and has_enough_data:
                globals.file_uploaded_start_flag = False
                som_iter = create_map(
                    globals.crunched_df,
                    cluster_distance=globals.cluster_distance,
                    lr=10**globals.lr,
                    epochs=globals.epochs,
                    size=globals.size,
                    sigma=globals.sigma,
                    label_column=globals.current_label_columns[0],
                    output_column=globals.current_output_columns[0],
                    variable_columns=globals.current_input_columns,
                    interval_epochs=globals.epochs//20,
                    output_influences=globals.output_influences == "Sim",
                    topology="rectangular" if globals.topology == "Retangular" else "hexagonal"
                )

                for i,som_data in enumerate(som_iter):
                    load_percentage = round((i+1) * (globals.epochs//20) * 100 / globals.epochs)
                    chart_title = f"Mapa SOM ({load_percentage}%)" if load_percentage < 100 else "Mapa SOM"
                    chart_data = som_data
                    chart_data.columns = ["Munic√≠pios", "Nota", "x", "y", "Cor", "Cor Central", "Grupo"]
                    ###################################################################################
                    globals.som_data = chart_data # OU USA ISSO AQUI PRA PEGAR OS RESULTADOS DO SOM!!!#
                    ###################################################################################

                    if globals.topology == "Retangular":
                        c = alt.Chart(globals.som_data).mark_square(filled=True).encode(
                            x="x",
                            y="y",
                            size="Nota",
                            color=alt.Color("Cor:N", scale=None),
                            tooltip=["Grupo", "Nota", "Munic√≠pios"]
                        ).interactive().configure_view(fill='black').properties(width=400, height=400, title=chart_title)
                    else:
                        c = alt.Chart(globals.som_data).mark_point(filled=True, shape=HEX_SHAPE).encode(
                            x="x",
                            y="y",
                            size="Nota",
                            color=alt.Color("Cor:N", scale=None),
                            tooltip=["Grupo", "Nota", "Munic√≠pios"]
                        ).interactive().configure_view(fill='black').properties(width=400, height=400, title=chart_title)

                    globals.som_chart = c
                    globals.som.altair_chart(globals.som_chart, use_container_width=True)
            
            global use_shap
            # globals.use_shap = st.checkbox("Incluir An√°lise Individual dos Munic√≠pios", help='Selecione para obter, ao fim da execu√ß√£o, uma an√°lise completa dos munic√≠pios de sua escolha individualmente')

        submit_button = st.button('**‚ñ∂Ô∏è  Executar**', type="primary")
        
        if submit_button:
            st.markdown('Voc√™ chegou ao fim da p√°gina de Aquisi√ß√£o de Dados e Parametriza√ß√£o. Para prosseguir com a aplica√ß√£o, volte para o topo da p√°gina e clique em "An√°lise Estat√≠stica Explorat√≥ria" para prosseguir at√© a pr√≥xima p√°gina.')
            rodar_algoritmo()
    else:
        globals.file_uploaded_start_flag = False
        globals.som_chart = None

tab1, tab2, tab3, tab4, tab5 = st.tabs(["Aquisi√ß√£o de Dados e Parametriza√ß√£o", "An√°lise Estat√≠stica Explorat√≥ria", "An√°lise de Agrupamentos", 'Mapa SOM', 'Relat√≥rios'])

with tab1:
   pagina_inicial()
with tab2:
   pagina_analise_estatistica_exploratoria()
with tab3:
    pagina_analise_por_grupos()
with tab4:
    pass
with tab5:
    relatorio_regioes()
    relatorio_municipios()